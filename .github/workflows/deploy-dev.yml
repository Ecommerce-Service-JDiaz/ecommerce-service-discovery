name: Deploy Dev

on:
  push:
    branches:
      - development
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

env:
  PROJECT_VERSION: 0.1.0
  IMAGE_NAME: ecommerce-service-discovery
  SERVICE_NAME: service-discovery
  ENVIRONMENT: dev

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Obtener secrets de Azure Key Vault
        id: get-kv-secrets
        env:
          RESOURCE_GROUP_KV: ${{ secrets.RESOURCE_GROUP_KV }}
        run: |
          KEY_VAULT_RG="$RESOURCE_GROUP_KV"
          
          if [ -z "$KEY_VAULT_RG" ]; then
            echo "ERROR: RESOURCE_GROUP_KV no está configurado en GitHub Secrets"
            exit 1
          fi
          
          echo "Buscando Key Vault en el Resource Group: $KEY_VAULT_RG"
          KEY_VAULT_NAME=$(az keyvault list --resource-group "$KEY_VAULT_RG" --query "[0].name" -o tsv)
          
          if [ -z "$KEY_VAULT_NAME" ]; then
            echo "ERROR: No se encontró ningún Key Vault en el Resource Group $KEY_VAULT_RG"
            exit 1
          fi
          
          echo "Key Vault encontrado: $KEY_VAULT_NAME"
          
          # Obtener secrets para DEV
          AZURE_RESOURCE_GROUP_DEV=$(az keyvault secret show --vault-name "$KEY_VAULT_NAME" --name "AZURE-RESOURCE-GROUP-DEV" --query "value" -o tsv)
          AKS_CLUSTER_NAME_DEV=$(az keyvault secret show --vault-name "$KEY_VAULT_NAME" --name "AKS-CLUSTER-NAME-DEV" --query "value" -o tsv)
          KUBERNETES_NAMESPACE_DEV=$(az keyvault secret show --vault-name "$KEY_VAULT_NAME" --name "KUBERNETES-NAMESPACE-DEV" --query "value" -o tsv)
          DOCKERHUB_USERNAME=$(az keyvault secret show --vault-name "$KEY_VAULT_NAME" --name "DOCKERHUB-USERNAME" --query "value" -o tsv)
          DOCKERHUB_TOKEN=$(az keyvault secret show --vault-name "$KEY_VAULT_NAME" --name "DOCKERHUB-TOKEN" --query "value" -o tsv)
          
          # Validar que se obtuvieron todos los secrets
          if [ -z "$AZURE_RESOURCE_GROUP_DEV" ] || [ -z "$AKS_CLUSTER_NAME_DEV" ] || [ -z "$DOCKERHUB_USERNAME" ] || [ -z "$DOCKERHUB_TOKEN" ]; then
            echo "ERROR: No se pudieron obtener todos los secrets del Key Vault"
            exit 1
          fi
          
          # Enmascarar valores
          echo "::add-mask::$AZURE_RESOURCE_GROUP_DEV"
          echo "::add-mask::$AKS_CLUSTER_NAME_DEV"
          echo "::add-mask::$DOCKERHUB_USERNAME"
          echo "::add-mask::$DOCKERHUB_TOKEN"
          
          # Exportar como outputs
          echo "AZURE_RESOURCE_GROUP_DEV<<EOF" >> $GITHUB_OUTPUT
          echo "$AZURE_RESOURCE_GROUP_DEV" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "AKS_CLUSTER_NAME_DEV<<EOF" >> $GITHUB_OUTPUT
          echo "$AKS_CLUSTER_NAME_DEV" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "KUBERNETES_NAMESPACE_DEV<<EOF" >> $GITHUB_OUTPUT
          echo "${KUBERNETES_NAMESPACE_DEV:-dev}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "DOCKERHUB_USERNAME<<EOF" >> $GITHUB_OUTPUT
          echo "$DOCKERHUB_USERNAME" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "DOCKERHUB_TOKEN<<EOF" >> $GITHUB_OUTPUT
          echo "$DOCKERHUB_TOKEN" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "✅ Secrets obtenidos exitosamente del Key Vault"

      - name: Set up JDK 11
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'
          cache: maven

      - name: Ejecutar pruebas unitarias
        run: mvn clean test jacoco:report

      - name: Verificar coverage
        run: |
          # Intentar obtener coverage de jacoco si está disponible
          if [ -f "target/site/jacoco/index.html" ]; then
            COVERAGE=$(grep -oP 'Total.*?(\d+\.\d+)%' target/site/jacoco/index.html | head -1 | grep -oP '\d+\.\d+' || echo "0")
            echo "Coverage actual: ${COVERAGE}%"
            COVERAGE_INT=$(echo "$COVERAGE" | awk '{printf "%.0f", $1}')
            if [ "$COVERAGE_INT" -lt 60 ]; then
              echo "::warning::Coverage es ${COVERAGE}%, menor al 60% requerido"
              echo "⚠️ ALERTA: El coverage de pruebas es ${COVERAGE}%, menor al 60% requerido"
            else
              echo "✅ Coverage de ${COVERAGE}% es aceptable"
            fi
          else
            echo "⚠️ ALERTA: No se encontró reporte de coverage. Asegúrate de configurar JaCoCo en el proyecto."
            echo "::warning::No se encontró reporte de coverage"
          fi

      - name: Compilar artefacto
        run: mvn clean package -DskipTests

      - name: Login en Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ steps.get-kv-secrets.outputs.DOCKERHUB_USERNAME }}
          password: ${{ steps.get-kv-secrets.outputs.DOCKERHUB_TOKEN }}

      - name: Construir y etiquetar imagen Docker
        env:
          DOCKER_REPOSITORY: ${{ steps.get-kv-secrets.outputs.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}
        run: |
          docker build -t ${{ env.IMAGE_NAME }}:${{ github.sha }} --build-arg PROJECT_VERSION=${{ env.PROJECT_VERSION }} .
          docker tag ${{ env.IMAGE_NAME }}:${{ github.sha }} $DOCKER_REPOSITORY:${{ github.sha }}
          docker tag ${{ env.IMAGE_NAME }}:${{ github.sha }} $DOCKER_REPOSITORY:dev
          docker tag ${{ env.IMAGE_NAME }}:${{ github.sha }} $DOCKER_REPOSITORY:latest

      - name: Publicar imagen en Docker Hub
        env:
          DOCKER_REPOSITORY: ${{ steps.get-kv-secrets.outputs.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}
        run: |
          docker push $DOCKER_REPOSITORY:${{ github.sha }}
          docker push $DOCKER_REPOSITORY:dev
          docker push $DOCKER_REPOSITORY:latest

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Configurar contexto AKS
        env:
          AZURE_RESOURCE_GROUP_DEV: ${{ steps.get-kv-secrets.outputs.AZURE_RESOURCE_GROUP_DEV }}
          AKS_CLUSTER_NAME_DEV: ${{ steps.get-kv-secrets.outputs.AKS_CLUSTER_NAME_DEV }}
        run: |
          az aks get-credentials \
            --resource-group "$AZURE_RESOURCE_GROUP_DEV" \
            --name "$AKS_CLUSTER_NAME_DEV" \
            --overwrite-existing

      - name: Crear namespace si no existe
        env:
          KUBERNETES_NAMESPACE_DEV: ${{ steps.get-kv-secrets.outputs.KUBERNETES_NAMESPACE_DEV }}
        run: |
          kubectl create namespace $KUBERNETES_NAMESPACE_DEV --dry-run=client -o yaml | kubectl apply -f -

      - name: Instalar envsubst
        run: |
          sudo apt-get update
          sudo apt-get install -y gettext-base

      - name: Crear o actualizar ConfigMap
        env:
          KUBERNETES_NAMESPACE_DEV: ${{ steps.get-kv-secrets.outputs.KUBERNETES_NAMESPACE_DEV }}
          DOCKER_REPOSITORY: ${{ steps.get-kv-secrets.outputs.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}
        run: |
          export NAMESPACE=$KUBERNETES_NAMESPACE_DEV
          export SPRING_PROFILE=${{ env.ENVIRONMENT }}
          export ZIPKIN_BASE_URL="http://zipkin:9411/"
          export JAVA_OPTS="-Xms256m -Xmx512m"
          export CONFIGMAP_NAME="service-discovery-config"
          export LOG_FILE_PATH="/var/log/service-discovery/${SPRING_PROFILE}_log.log"
          export LOG_CLEAN_HISTORY_ON_START="false"
          
          # Crear ConfigMap usando envsubst
          envsubst < k8s/configmap-template.yaml | kubectl apply -f -
          
          echo "✅ ConfigMap creado/actualizado exitosamente"

      - name: Crear Secret de Docker Hub si no existe
        env:
          KUBERNETES_NAMESPACE_DEV: ${{ steps.get-kv-secrets.outputs.KUBERNETES_NAMESPACE_DEV }}
          DOCKERHUB_USERNAME: ${{ steps.get-kv-secrets.outputs.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ steps.get-kv-secrets.outputs.DOCKERHUB_TOKEN }}
        run: |
          SECRET_NAME="dockerhub-secret"
          
          # Verificar si el secret ya existe
          if kubectl get secret $SECRET_NAME -n $KUBERNETES_NAMESPACE_DEV &>/dev/null; then
            echo "Secret $SECRET_NAME ya existe, actualizando..."
            kubectl delete secret $SECRET_NAME -n $KUBERNETES_NAMESPACE_DEV
          fi
          
          # Crear secret de Docker Hub
          kubectl create secret docker-registry $SECRET_NAME \
            --docker-server=https://index.docker.io/v1/ \
            --docker-username="$DOCKERHUB_USERNAME" \
            --docker-password="$DOCKERHUB_TOKEN" \
            --namespace=$KUBERNETES_NAMESPACE_DEV
          
          echo "✅ Secret de Docker Hub creado/actualizado exitosamente"

      - name: Aplicar manifiestos de Kubernetes
        env:
          KUBERNETES_NAMESPACE_DEV: ${{ steps.get-kv-secrets.outputs.KUBERNETES_NAMESPACE_DEV }}
          DOCKER_REPOSITORY: ${{ steps.get-kv-secrets.outputs.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          export NAMESPACE=$KUBERNETES_NAMESPACE_DEV
          export ENVIRONMENT=${{ env.ENVIRONMENT }}
          export IMAGE_TAG=$DOCKER_REPOSITORY:$IMAGE_TAG
          export DOCKERHUB_SECRET_NAME="dockerhub-secret"
          export CONFIGMAP_NAME="service-discovery-config"
          export SPRING_PROFILE=${{ env.ENVIRONMENT }}
          export ZIPKIN_BASE_URL="http://zipkin:9411/"
          
          if [ -f "k8s/deployment-dev.yml" ] || [ -f "k8s/deployment-dev.yaml" ]; then
            DEPLOYMENT_FILE=$(ls k8s/deployment-dev.* 2>/dev/null | head -1)
            if [ -n "$DEPLOYMENT_FILE" ]; then
              echo "Aplicando deployment con variables reemplazadas..."
              envsubst < $DEPLOYMENT_FILE | kubectl apply -f -
              echo "✅ Deployment aplicado exitosamente"
            fi
          else
            echo "⚠️ No se encontró archivo deployment-dev.yaml"
            exit 1
          fi

      - name: Verificar despliegue
        env:
          KUBERNETES_NAMESPACE_DEV: ${{ steps.get-kv-secrets.outputs.KUBERNETES_NAMESPACE_DEV }}
        run: |
          kubectl rollout status deployment/${{ env.SERVICE_NAME }} -n $KUBERNETES_NAMESPACE_DEV --timeout=300s || kubectl get pods -n $KUBERNETES_NAMESPACE_DEV
          echo "✅ Despliegue completado exitosamente"
