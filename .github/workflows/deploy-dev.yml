name: Deploy Dev

on:
  push:
    branches:
      - develop
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

env:
  PROJECT_VERSION: 0.1.0
  IMAGE_NAME: ecommerce-service-discovery
  SERVICE_NAME: service-discovery
  ENVIRONMENT: dev

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Obtener secrets de Azure Key Vault
        id: get-kv-secrets
        env:
          RESOURCE_GROUP_KV: ${{ secrets.RESOURCE_GROUP_KV }}
        run: |
          KEY_VAULT_RG="$RESOURCE_GROUP_KV"
          
          if [ -z "$KEY_VAULT_RG" ]; then
            echo "ERROR: RESOURCE_GROUP_KV no está configurado en GitHub Secrets"
            exit 1
          fi
          
          echo "Buscando Key Vault en el Resource Group: $KEY_VAULT_RG"
          KEY_VAULT_NAME=$(az keyvault list --resource-group "$KEY_VAULT_RG" --query "[0].name" -o tsv)
          
          if [ -z "$KEY_VAULT_NAME" ]; then
            echo "ERROR: No se encontró ningún Key Vault en el Resource Group $KEY_VAULT_RG"
            exit 1
          fi
          
          echo "Key Vault encontrado: $KEY_VAULT_NAME"
          
          # Obtener secrets para DEV
          AZURE_RESOURCE_GROUP_DEV=$(az keyvault secret show --vault-name "$KEY_VAULT_NAME" --name "AZURE-RESOURCE-GROUP-DEV" --query "value" -o tsv)
          AKS_CLUSTER_NAME_DEV=$(az keyvault secret show --vault-name "$KEY_VAULT_NAME" --name "AKS-CLUSTER-NAME-DEV" --query "value" -o tsv)
          AKS_NAMESPACE_DEV=$(az keyvault secret show --vault-name "$KEY_VAULT_NAME" --name "AKS-NAMESPACE-DEV" --query "value" -o tsv)
          DOCKERHUB_USERNAME=$(az keyvault secret show --vault-name "$KEY_VAULT_NAME" --name "DOCKERHUB-USERNAME" --query "value" -o tsv)
          DOCKERHUB_TOKEN=$(az keyvault secret show --vault-name "$KEY_VAULT_NAME" --name "DOCKERHUB-TOKEN" --query "value" -o tsv)
          
          # Validar que se obtuvieron todos los secrets
          if [ -z "$AZURE_RESOURCE_GROUP_DEV" ] || [ -z "$AKS_CLUSTER_NAME_DEV" ] || [ -z "$DOCKERHUB_USERNAME" ] || [ -z "$DOCKERHUB_TOKEN" ]; then
            echo "ERROR: No se pudieron obtener todos los secrets del Key Vault"
            exit 1
          fi
          
          # Enmascarar valores
          echo "::add-mask::$AZURE_RESOURCE_GROUP_DEV"
          echo "::add-mask::$AKS_CLUSTER_NAME_DEV"
          echo "::add-mask::$DOCKERHUB_USERNAME"
          echo "::add-mask::$DOCKERHUB_TOKEN"
          
          # Exportar como outputs
          echo "AZURE_RESOURCE_GROUP_DEV<<EOF" >> $GITHUB_OUTPUT
          echo "$AZURE_RESOURCE_GROUP_DEV" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "AKS_CLUSTER_NAME_DEV<<EOF" >> $GITHUB_OUTPUT
          echo "$AKS_CLUSTER_NAME_DEV" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "AKS_NAMESPACE_DEV<<EOF" >> $GITHUB_OUTPUT
          echo "${AKS_NAMESPACE_DEV:-dev}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "DOCKERHUB_USERNAME<<EOF" >> $GITHUB_OUTPUT
          echo "$DOCKERHUB_USERNAME" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "DOCKERHUB_TOKEN<<EOF" >> $GITHUB_OUTPUT
          echo "$DOCKERHUB_TOKEN" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "✅ Secrets obtenidos exitosamente del Key Vault"

      - name: Set up JDK 11
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'
          cache: maven

      - name: Ejecutar pruebas unitarias
        run: mvn clean test

      - name: Verificar coverage
        run: |
          # Intentar obtener coverage de jacoco si está disponible
          if [ -f "target/site/jacoco/index.html" ]; then
            COVERAGE=$(grep -oP 'Total.*?(\d+\.\d+)%' target/site/jacoco/index.html | head -1 | grep -oP '\d+\.\d+' || echo "0")
            echo "Coverage actual: ${COVERAGE}%"
            COVERAGE_INT=$(echo "$COVERAGE" | awk '{printf "%.0f", $1}')
            if [ "$COVERAGE_INT" -lt 60 ]; then
              echo "::warning::Coverage es ${COVERAGE}%, menor al 60% requerido"
              echo "⚠️ ALERTA: El coverage de pruebas es ${COVERAGE}%, menor al 60% requerido"
            else
              echo "✅ Coverage de ${COVERAGE}% es aceptable"
            fi
          else
            echo "⚠️ ALERTA: No se encontró reporte de coverage. Asegúrate de configurar JaCoCo en el proyecto."
            echo "::warning::No se encontró reporte de coverage"
          fi

      - name: Compilar artefacto
        run: mvn clean package -DskipTests

      - name: Login en Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ steps.get-kv-secrets.outputs.DOCKERHUB_USERNAME }}
          password: ${{ steps.get-kv-secrets.outputs.DOCKERHUB_TOKEN }}

      - name: Construir y etiquetar imagen Docker
        env:
          DOCKER_REPOSITORY: ${{ steps.get-kv-secrets.outputs.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}
        run: |
          docker build -t ${{ env.IMAGE_NAME }}:${{ github.sha }} --build-arg PROJECT_VERSION=${{ env.PROJECT_VERSION }} .
          docker tag ${{ env.IMAGE_NAME }}:${{ github.sha }} $DOCKER_REPOSITORY:${{ github.sha }}
          docker tag ${{ env.IMAGE_NAME }}:${{ github.sha }} $DOCKER_REPOSITORY:dev
          docker tag ${{ env.IMAGE_NAME }}:${{ github.sha }} $DOCKER_REPOSITORY:latest

      - name: Publicar imagen en Docker Hub
        env:
          DOCKER_REPOSITORY: ${{ steps.get-kv-secrets.outputs.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}
        run: |
          docker push $DOCKER_REPOSITORY:${{ github.sha }}
          docker push $DOCKER_REPOSITORY:dev
          docker push $DOCKER_REPOSITORY:latest

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Configurar contexto AKS
        env:
          AZURE_RESOURCE_GROUP_DEV: ${{ steps.get-kv-secrets.outputs.AZURE_RESOURCE_GROUP_DEV }}
          AKS_CLUSTER_NAME_DEV: ${{ steps.get-kv-secrets.outputs.AKS_CLUSTER_NAME_DEV }}
        run: |
          az aks get-credentials \
            --resource-group "$AZURE_RESOURCE_GROUP_DEV" \
            --name "$AKS_CLUSTER_NAME_DEV" \
            --overwrite-existing

      - name: Crear namespace si no existe
        env:
          AKS_NAMESPACE_DEV: ${{ steps.get-kv-secrets.outputs.AKS_NAMESPACE_DEV }}
        run: |
          kubectl create namespace $AKS_NAMESPACE_DEV --dry-run=client -o yaml | kubectl apply -f -

      - name: Aplicar manifiestos de Kubernetes
        env:
          AKS_NAMESPACE_DEV: ${{ steps.get-kv-secrets.outputs.AKS_NAMESPACE_DEV }}
          DOCKER_REPOSITORY: ${{ steps.get-kv-secrets.outputs.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          if [ -d "k8s/dev" ]; then
            kubectl apply -f k8s/dev -n $AKS_NAMESPACE_DEV
            kubectl set image deployment/${{ env.SERVICE_NAME }} ${{ env.SERVICE_NAME }}=$DOCKER_REPOSITORY:$IMAGE_TAG -n $AKS_NAMESPACE_DEV --ignore-not-found=true
          elif [ -f "k8s/deployment-dev.yml" ] || [ -f "k8s/deployment-dev.yaml" ]; then
            DEPLOYMENT_FILE=$(ls k8s/deployment-dev.* 2>/dev/null | head -1)
            if [ -n "$DEPLOYMENT_FILE" ]; then
              kubectl apply -f $DEPLOYMENT_FILE -n $AKS_NAMESPACE_DEV
              kubectl set image deployment/${{ env.SERVICE_NAME }} ${{ env.SERVICE_NAME }}=$DOCKER_REPOSITORY:$IMAGE_TAG -n $AKS_NAMESPACE_DEV --ignore-not-found=true
            fi
          else
            echo "⚠️ No se encontraron manifiestos de Kubernetes. Creando deployment básico..."
            kubectl create deployment ${{ env.SERVICE_NAME }} \
              --image=$DOCKER_REPOSITORY:$IMAGE_TAG \
              --namespace=$AKS_NAMESPACE_DEV \
              --dry-run=client -o yaml | kubectl apply -f -
          fi

      - name: Verificar despliegue
        env:
          AKS_NAMESPACE_DEV: ${{ steps.get-kv-secrets.outputs.AKS_NAMESPACE_DEV }}
        run: |
          kubectl rollout status deployment/${{ env.SERVICE_NAME }} -n $AKS_NAMESPACE_DEV --timeout=300s || kubectl get pods -n $AKS_NAMESPACE_DEV
          echo "✅ Despliegue completado exitosamente"
